

By now, you should be familiar with all the fundamental JavaScript data types, including objects.

We can use existing objects (or ones we create ourselves) to pass around information and functionality.

Understanding the fundamentals of objects is essential to using JavaScript to build our sites and applications.



In previous units, we've relied on `console.log` and `alert` to give feedback to users, but these will only get us so far.

In this unit, we'll look at how we can provide more meaningful feedback and make our sites more user friendly by allowing users to interact with our site and see its contents update in real time.



Let's walk through some of the primary aspects of the DOM.






1) The DOM allows you to find elements.

JavaScript exposes the DOM of browser pages as an object that we can access called “document.”

This allows us to search through and access elements on the page such as links, images, paragraphs, etc.


![](http://circuits-assets.generalassemb.ly/prod/asset/4584/Slide-5-Documents.svg)






2) The DOM allows you to _get_ content.

The DOM makes it easy to access content within a page, especially when you want to find out what information a user has entered into a form field.

The answers could include email addresses, first and last names, and more.


![](http://circuits-assets.generalassemb.ly/prod/asset/4585/Slide-6-Form-Email.svg)






3) The DOM allows you to _set_ content.

The DOM also allows us to dynamically update the content of the HTML elements on our page.

Maybe we want to change the text of the h1 to read "JavaScript Ninja's Website", or maybe we want to update the src attribute of an image when the user clicks a "next" button. We can dynamically update any of the HTML, text content, or attributes for the elements on our page.


![](http://circuits-assets.generalassemb.ly/prod/asset/4585/Slide-6-Form-Email.svg)






4) The DOM allows you to add animations and effects.

This is where things start to get fun! Maybe we want a dropdown menu to slide down when a user clicks on an icon. Or, maybe we want a "Success!" message to fade in when our user submits a form.

Perhaps we want different images to fade in and out as a user scrolls down the page. All of this is possible with JavaScript!




![](http://circuits-assets.generalassemb.ly/prod/asset/4586/Slide-7-Sidebar.svg)






5) The DOM allows you to create **event listeners**.

We will learn more about event listeners later in this unit. Basically, we don't always want the final state of our page to be the same as its initial state.

JavaScript allows us to react to the user's actions by having the DOM "listen", or "wait," for a user to take an action (trigger an event) before we run a block of code.


![](http://circuits-assets.generalassemb.ly/prod/asset/4587/Slide-8-Loading.svg)



Let's take a look at some examples.




<div class="col" style="padding-right: 30px;">

When our page loads, we may want to keep it clean and crisp by not displaying the navigation bar (nav) at the top.

Instead, when the user scrolls down, we want the nav to fade in and stick to the top of the page.

![](http://circuits-assets.generalassemb.ly/prod/asset/4641/Slide-9.gif


Or, perhaps you want your page to notify users if the information they entered was in the wrong format when they hit tab on a form field.

Another would be when we want to submit, or send, data when the user clicks on a submit button.

These are just a few of the event listeners we’ll explore in this unit.



To review, the DOM allows us to:

![](http://circuits-assets.generalassemb.ly/prod/asset/4588/Slide-10-4-Reasons.svg


So, what does the DOM look like in action?

Let’s take a look:






Here we have some very basic HTML; just a heading and a div with the class `circle`.

Once this code is loaded into the browser, we can update it dynamically and see the results in real time.
![](http://circuits-assets.generalassemb.ly/prod/asset/4642/Slide-12.png





We are using JavaScript to find, or select, the element with the class circle and change the background color to red.



![](http://circuits-assets.generalassemb.ly/prod/asset/4643/Slide-13.gif)






Here's another example of the DOM in action:

See how the text is changed in real time, without a page refresh?

![](http://circuits-assets.generalassemb.ly/prod/asset/4644/Slide-14.gif


Before we get too deep into the DOM, let’s watch a video to better understand how it works in the browser.



As we’ve seen, the browser pulls in these HTML documents, parses them, and creates object models of the pages in its memory.

This model is the Document Object Model (DOM).






The DOM is structured like a tree, which we (unsurprisingly) call the DOM Tree.

Each element in the HTML document is represented by a DOM node.

![](http://circuits-assets.generalassemb.ly/prod/asset/4589/Slide-16-DOM-Tree.svg)






You can think of a node as a live object you can access and change using JavaScript.

When the model is updated, those changes are reflected on screen.



![](http://circuits-assets.generalassemb.ly/prod/asset/4590/Slide-17-DOM-Tree-Annotated.svg)



As a note, you may sometimes hear developers use the terms "node" and "element" interchangeably.

They often say things like "Let's select an element to work with," instead of "Let's select a node to work with.”





Here’s how the DOM Tree structure works within the web page for a simple to-do list:

![](http://circuits-assets.generalassemb.ly/prod/asset/4645/Slide-20.png


Perhaps we want to add a class or update styling to change the background color for an element.

The DOM allows us to get and set attributes for these nodes.






In our to-do list, we can access and change its content — for example if we wanted change the text in the third `<li>` to read "Return library books — DONE!"

We can even add new nodes to the page, or remove ones we no longer want.



![](http://circuits-assets.generalassemb.ly/prod/asset/4786/Screen_Shot_2016-07-06_at_1.48.01_PM.png)



So, the DOM is a (potentially) large object that describes the structure of our content. Because it's an object, we can use standard techniques to get and set data.

In the browser, the DOM is represented by the `document` object. Luckily, JS specifies some built-in methods that make the DOM easier to us.



Before learning more about the DOM, let's get a quick refresher on HTML and browsers since we'll be working closely with both throughout this unit.



## What is HTML?

According to the Mozilla Developer Network, "HTML, which stands for HyperText Markup Language, is the most basic building block of a web page, and used for creating and visually representing a web page." (Source [mdn](https://developer.mozilla.org/en-US/docs/Web/HTML))



## What is HTML?

HTML is considered a _markup_ language, meaning it simply provides content and **structure** to a document. On the other hand, JavaScript is a programming language, which allows for more **functionality** and interactivity.






Let’s look at an example.

Here, we have some content — in this case a recipe for chocolate chip cookies —, and we can provide the structure for this content using HTML elements.



![](http://circuits-assets.generalassemb.ly/prod/asset/4646/Slide-25.png)



Elements are the basic building blocks of HTML.

An element looks like this:

![](http://circuits-assets.generalassemb.ly/prod/asset/4591/Slide-23-HTML-Tag-Annotated.svg)

We have an opening tag, a closing tag, and some content in between the two.

This entire chunk is what we call an _element_.



Again, elements allow us to add _structure_ to the content of our page.

For example, if we have a major headline on our page, we want to wrap it with h1 tags, like so:

# <h1>For Immediate Release</h1>



If we have a paragraph of text, we wrap that paragraph with p tags, like so:

**<p>**General Assembly, which started in New York as a startup incubator, now offers classes and workshops in technology, design, business, and entrepreneurship, with campuses around the world.**</p>**






Here's a diagram summarizing the difference between HTML, CSS, and JavaScript.

![](http://circuits-assets.generalassemb.ly/prod/asset/4592/Slide-25-HTML-CSS-JS.svg


We add _structure_ using HTML, _style_ using CSS, and _behavior_ using JavaScript.






If we were to compare these programming languages to parts of speech in English, HTML would be our noun, providing our page with structure; CSS would be our adjective, as it describes, or styles, our page; and JavaScript would be our verb, because it adds interactivity, or behavior, to our page.

![](http://circuits-assets.generalassemb.ly/prod/asset/4593/Slide-26-HTML-CSS-JS-Annotated.svg


Now that we've reviewed some basic HTML, let's take a look behind the scenes at how browsers work.

We often view webpages on browsers. The most commonly used browsers are Chrome, Firefox, Safari, and Internet Explorer.

![](http://circuits-assets.generalassemb.ly/prod/asset/5144/web-browsers.png


A web browser (commonly referred to as a browser) is a software application that allows users to retrieve, present, and find information resources on the World Wide Web, such as the HTML, CSS, and JS sent from the web applications (or apps).






How does the browser work? They're built upon **rendering engines**.

A web browser’s engine is a program that renders marked-up content (such as HTML, image files, etc.) and formatting information (such as CSS).



![](http://circuits-assets.generalassemb.ly/prod/asset/4972/Slide-28-Rendering-Engine.svg)





So what does this process look like?

![](http://circuits-assets.generalassemb.ly/prod/asset/4596/Slide-29-Process-Step-1.svg


The rendering engine starts by parsing an HTML document and converting its elements into DOM nodes, ordering them in **content tree** (also referred to as the DOM Tree).





To **parse** means to analyze a set of characters or data (HTML, for example).

![](http://circuits-assets.generalassemb.ly/prod/asset/4597/Slide-30-HTML-DOM-Tree.svg
![](http://circuits-assets.generalassemb.ly/prod/asset/4598/Slide-31-Process-Step-2.svg)

The browser’s rendering engine then parses, or analyzes, styles found in external stylesheets and in style elements in the head of the page.

It then creates a map of which styles should be applied to different parts of the page according to the CSS. This map is known as the CSSOM, or the CSS object map.

![](http://circuits-assets.generalassemb.ly/prod/asset/4599/Slide-32-CSS-DOM-Tree.svg




The browser then combines the CSSOM and the DOM to create another tree, the **render tree**.



![](http://circuits-assets.generalassemb.ly/prod/asset/5151/render-tree-construction.png)





The render tree is essentially a map of how the page should be laid out and painted.



![](http://circuits-assets.generalassemb.ly/prod/asset/5151/render-tree-construction.png)



![](http://circuits-assets.generalassemb.ly/prod/asset/4601/Slide-34-Process-Step-3.svg)

At this point, the browser knows what content should be displayed (the DOM), how it should be displayed (the CSSOM), and how the two are related (the render tree).



Depending on the screen size, elements may end up in different places.

For example, if we have a div element that is supposed to take up 75% of the page width, the actual width of that div element will depend on the width of the browser window.

If the browser window is 1000px wide, the width of the div will be 750px (75% of 1000px).

If the browser window is 500px wide, the width of the div will be 375px (75% of 500px).






During this step, the rendering engine determines the size of the screen and how this measurement will affect the page’s layout.

![](http://circuits-assets.generalassemb.ly/prod/asset/4602/Slide-35-Screen.svg





Each node will be given the exact coordinates for where it should appear on the screen.

This step is often referred to as layout, or reflow.

![](http://circuits-assets.generalassemb.ly/prod/asset/4602/Slide-35-Screen.svg
![](http://circuits-assets.generalassemb.ly/prod/asset/5043/Slide-47-Process-Step-4.svg)

Finally, the rendering engine has all the information it needs to display our page on the screen. The only step left is **painting** the render tree.



During this step, the browser scans the render tree and renders, or displays, the pixels for each node on the screen.

This is where the magic happens — now, our page can finally be seen by our users.



Now that we have a better understanding of what goes on behind-the-scenes in our browser, let's dig a little bit deeper into the DOM.




![](http://circuits-assets.generalassemb.ly/prod/asset/4589/Slide-16-DOM-Tree.svg


The DOM is an object presentation of an app’s HTML document and serves as an interface with which JavaScript can interact.

Because it is an object, we can use normal techniques to get and set data within it. JS specifies some built-in methods that make using the DOM even easier.



For example, if we want to grab a user input from a form, we could code “document.getElementById(String id).value”, and JS would search the document object for an element by its ID name.



Here, we are searching through the document object, as it is the root node of the HTML document and the "owner" of all other element nodes.

When we say "root node,” we mean that the document object contains all of the other element nodes that we'll want to manipulate.

Once JS has found our input element, it then gets the value of that element — in this case, whatever the user entered in the form.



In the example below, our element is an email address the user entered to create an account with the application:

    <form>

      Submit
    </form>



Here's what that code would display:

![](http://circuits-assets.generalassemb.ly/prod/asset/4648/Slide-40.png


It’s common for front-end developers to work with the DOM while developing. But, how do they do it?

Two words: Developer tools.

Most browsers offer a developer tools feature which allows users to inspect and play with the DOM.






For example, if you are using a Chrome browser, you can click anywhere within the site you're viewing and select "Inspect" to open Developer Tools.



![](http://circuits-assets.generalassemb.ly/prod/asset/5143/inspect_element.png)






Or you can type the following shortcuts:
**Mac** - Command + Shift + C
**Windows / Linux** - Ctrl + Shift + C or F12.



![](http://circuits-assets.generalassemb.ly/prod/asset/5143/inspect_element.png)



When you look at the “elements” panel in developer tools, you’re seeing the browser’s rendered version of HTML (the DOM).

It should look similar to your normal HTML, but you’ll notice it isn’t exactly the same.



Let’s see what the HTML document looks like in our to-do-list example:

![](http://circuits-assets.generalassemb.ly/prod/asset/4650/Slide-45.png


The DOM is a living model of the page, made up of node objects that can be manipulated with JavaScript.

If your HTML isn’t properly structured (i.e. you’re missing any required elements) the browser will fix its structure as it renders.



And, if you want to use JS to manipulate the DOM (by adding elements, for example), your DOM will render dynamically. On the other hand, your HTML wouldn’t reflect these changes as it is static.

Say we want to use JavaScript to add a fourth list item to the page — "Feed the cat." Then, perhaps we want to change the background-color of the first list item to yellow. And, maybe we want to change the text content of the third list item to "Return library books — DONE!"





Here is what the DOM looks like with our new changes:

![](http://circuits-assets.generalassemb.ly/prod/asset/4651/Slide-48.png


The DOM has changed quite a bit from our original HTML file.

*   We added a fourth list item that wasn't in our HTML file (Feed the cat)

*   We changed the background color of our first list item to yellow (notice the inline style attribute added to the first list item:

        <li style="background-color: yellow;"> Call Mom </li>

*   We also updated the third list item to read "Return library books - DONE!"



Let’s see what it takes to add JavaScript to your HTML.

HTML renders line by line, so it’s important to think about where we’ll place our JS.



First, we'll need to create a JavaScript file. The process is similar to creating any other file, we just want to use a .js extension for JS. Common names for JavaScript files are main.js and script.js.



On larger sites, we'll want to house all of our JavaScript files in a folder to them organized. It's common to call this folder “js” or “scripts.”



Just like we need to add a `<link>` tag when we want to tell our browser where it can find the CSS files associated with our HTML page, we need to add a `<script>` tag to let the browser know where it can find the page’s associated JS files.

We recommend you include your JS files right before the closing `</body>` tag in your HTML code.


![](http://circuits-assets.generalassemb.ly/prod/asset/5058/Slide-67-Order.svg


If you have multiple JS files that depend on one another, it matters what order you place them in your HTML.

Because HTML is parsed by the browser from the top down, any **libraries** (define on the next slide) we add to our project must appear above any other JS files using these libraries.

If not, the JS script will crash when it tries to use any methods defined in that library, because it won’t know those methods exist.



A **library** is a file that contains pre-written code you can download and include in your project.

It allows you to take code that other developers have written and use its functionality code so you don't always have to write everything from scratch.

We'll be working closely with the jQuery library later in this course.



Now, make sure your JS file is hooked up to your HTML correctly:

![](http://circuits-assets.generalassemb.ly/prod/asset/5059/Slide-54.png


In this lesson, we took the first step towards adding more interactivity to our pages by learning about the Document Object Model.



Until now we’ve taken a high-level view of JavaScript. You learned how the browser pulls in an HTML file; creates a model of that file in its memory, and renders live objects, or nodes, for each element on that page. We can then update these nodes to add interactivity and update our pages dynamically.



We also took a look behind the scenes at what happens within a browser, from when a user types a website’s URL into a search bar to when that website visit is actually rendered and displayed on the page.



We dove into developer tools and saw how we can use them to examine the DOM. A key concept to remember is that, any time we make changes with JavaScript, those changes are reflected in the DOM.

If we update text content, we will see those updates in the elements panel. If we add styles, we will see those styles added to the DOM as inline attributes on our HTML elements.



In the next lesson, you'll try your hand at manipulating, or updating, the DOM.

Are you ready?






Earlier in this unit, we discussed how, when a browser retrieves the HTML for a page, it makes a model of that page in its memory.

This model is called the DOM.



![](http://circuits-assets.generalassemb.ly/prod/asset/4590/Slide-17-DOM-Tree-Annotated.svg)






Each element in an HTML document is represented by a **DOM node**.

You can think of a node as a _live object_ you can access and change using JavaScript.

When the model is updated, those changes are reflected on screen.

![](http://circuits-assets.generalassemb.ly/prod/asset/4603/Slide-4-DOM-Tree-Annotated.svg



![](http://circuits-assets.generalassemb.ly/prod/asset/4604/Slide-5-Steps.svg


Before we can update a page, we need to find, or select, the element(s) that we want to update.

So, let’s learn about how we can find, or access, elements.



In order to find an element, we need to search through the document. The syntax for the search looks something like this:

    document.getElementById('main')



Let's break this syntax down.

    document.getElementById('main')



`document` — Refers to the document object. Any time we want to find an element, we'll need to access it through the document object. This will allow us to search throughout the entire page.

    document.getElementById('main')



`.` The dot ties the method on the right-hand side (`getElementById`) with the object on the left-hand side (`document`).

    document.getElementById('main')



`getElementById()` — Is the method we want to use to find an element. This particular method allows us to locate an element by the value of its `id` attribute. We'll take a look at the other methods available to us later in the lesson.

    document.getElementById('main')



`'main'` — Just like with the functions we learned about earlier in this unit, we can pass in parameters for these methods to use. In this case, we want to find an element that has an `id` of `main`.

    document.getElementById('main')



As with all methods, using proper syntax here is important. These methods are case sensitive.

Typing in `document.getElementByID` with a capital D will _not_ work and throw an error.



Now, let’s explore how to select an individual element.

There are a two methods we can use: `getElementById()` and `querySelector()`

Here’s a closer look at both.



![](http://circuits-assets.generalassemb.ly/prod/asset/4605/Slide-12-Method-Circle.svg)

The fastest route to finding any single element is `getElementById()`.



As you may know from HTML and CSS, IDs are like labels we attach to elements in our HTML file by adding an `id` attribute to a specific element.

IDs are unique, meaning two elements cannot have the same value for an id attribute in any given HTML page.

    Content



We can then use an ID to target, or select, its corresponding element so we can add styles with CSS.

    #main-nav {
      text-align: center;
    }



You can think of IDs like serial numbers for products—they are used to uniquely identify a single element.

![](http://circuits-assets.generalassemb.ly/prod/asset/4606/Slide-15-Serial-Number.svg


We can also use IDs to select, or target, an element that we want to update. Because only one element on a page can have that specific ID, JavaScript's `getElementById()` query allows us to quickly find this individual element.



## HTML

    Related Articles

    Article One
    Article Two
    Article Three

First, we will add an `id` attribute to the element that we want to update. In this case, we've added the `id` 'sidebar' to the div that wraps, or contains, the sidebar content.



## JavaScript

    var sidebar = document.getElementById('sidebar');

We can then use JavaScript to search through the document object and find the element with an `id` of `sidebar`.



## JavaScript

    var sidebar = document.getElementById('sidebar');

Here, we are storing the results of the `document.getElementById('sidebar')` query in the variable `sidebar`.



## JavaScript

    var sidebar = document.getElementById('sidebar');

If we'd like to work with that element multiple times, a variable should be used to store, or **cache**, the results of our query.One of the benefits of caching is peformance. By saving the result of the query to a variable, you don't have to execute the query multiple times (which can be costly for complex queries or large web pages).



When we store an element in a variable, we are storing a reference to the location of that element in the DOM tree.

We can then use any methods we would normally use on an element on that variable.



It’s your turn to give things a try.



    Colors

    Red
    Blue
    Yellow

How could we use the `getElementById` method to select the list item with an id of:

*   Red? `document.getElementById('red')`
*   Blue? `document.getElementById('blue')`
*   Yellow? `document.getElementById('yellow')`

<div class="repl-console" data-lang="javascript">`document.body.innerHTML = '

# Colors

*   Red
*   Blue
*   Yellow

';


Great! Now that you’ve got that under your belt, let’s talk about using `querySelector()`.



`querySelector()` is a method that allows us to use our CSS selector syntax to find an element.

If there are multiple elements on a page that match the selector, it will return the first of those matching elements.



Similar to getElementById, we are only selecting one element.

It is important to note that this is a recent addition to the DOM and is not supported by older browsers.

`document.querySelector('.special')`

This code will return the _first_ element on the page with `class` of `special`. You can use any of your CSS-style selectors as a parameter.



Let’s look at a few other examples.



You can see here that, similar to when we select an element by the class name ‘special,’ we are using a CSS-style selector within the parentheses to select the element with an ID of sidebar, `#sidebar`.

    document.querySelector('#sidebar')

This will return the first element that has an ID of sidebar.



Here we are also using a CSS-style selector to select a `li` that is a descendent of the `ul`.

    document.querySelector('ul li')

This will return the first <li> that is a descendant of the <ul>.



It’s your turn to give things a try.



    Colors

    Red
    Blue
    Yellow

How could we use the `querySelector` method to do the following:

*   Select the first list item on the page?<span class="fragment">
    `document.querySelector('li')`</span>
*   Select the element that has the id yellow?<span class="fragment">
    `document.querySelector('#yellow')`</span>
*   Select the ul ?<span class="fragment">
    `document.querySelector('ul')`</span>

<div class="repl-console" data-lang="javascript">`document.body.innerHTML = '

# Colors

*   Red
*   Blue
*   Yellow

';


So far, the methods we’ve used to search through the `document` object have only been returning a single element.

But sometimes we'll want to find and work with several elements at once.

There are several methods we can use to return a **NodeList**, or _list of node objects_, to manipulate.



Let's take a look at some of the methods we can use to search through documents and find multiple elements.

![](http://circuits-assets.generalassemb.ly/prod/asset/5145/Slide-34-Method-Circle2.svg


We’ll be referencing this HTML snippet for each of our methods:

    Days of the Week

    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    Sunday

Here we have an `h1` with the title of our simple page and an unordered list with days of the week.



First, let’s focus on `document.getElementsByClassName()`. This method allows you to select all elements with a given class attribute.

`document.getElementsByClassName('special')`

This will return any elements that have the class `special`. In our "days of the week" example, this will return a NodeList containing the second and third list items, as they both have the class `special`.



Test yourself!

      Here's a special message.

      Here's a warning message.

How could we use the `getElementsByClassName` method to select all elements with the class `special`?

`document.getElementsByClassName('special')


Here’s another:



      Here's a special message.

      Here's a warning message.

How could we use the `getElementsByClassName` method to do the following:

*   Select all elements with the class 'warning'?

`document.getElementsByClassName('warning')


      Here's a special message.

      Here's a warning message.

How could we use the `getElementsByClassName` method to do the following:

*   select all elements with the class alert

`document.getElementsByClassName('alert')


You’re on a roll!

Let’s keep it going with `document.getElementsByTagName()`

This method locates all elements that match a given tag name.

`document.getElementsByTagName('li')`

Here, this query will return all `<li>` elements. In this case, the NodeList will contain all seven `<li>`.

    Days of the Week

        Monday
        Tuesday
        Wednesday
        Thursday
        Friday
        Saturday
        Sunday



Let’s try it again:



    Colors

    Red
    Blue
    Yellow

How could we use the `getElementsByTagName` method to do the following:

*   Select all 'li' elements

`document.getElementsByTagName('li')


    Colors

    Red
    Blue
    Yellow

How could we use the `getElementsByTagName` method to do the following:

*   Select all 'ul' elements?

`document.getElementsByTagName('ul')


Great!

Now, let’s try out `document.querySelectorAll()`

While this command may look similar to our `querySelector()` method, the `.querySelectorAll()` method allows us to use our CSS selector syntax to select one or more elements.



    Days of the Week

    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Sunday

`document.querySelectorAll('.special')`

This will return any elements with the class `special`. In the example above, this will return a NodeList containing the second and third list items, as they both have the class `special`.



Let’s see how well you understood `querySelectorAll()`:



    Colors

    Red
    Blue
    Yellow

How could we use the `querySelectorAll` method to do the following:

*   Select all 'li' elements?

`document.querySelectorAll('li')


    Colors

    Red
    Blue
    Yellow

How could we use the `querySelectorAll` method to do the following:

*   Select all 'ul' elements?

`document.querySelectorAll('ul')


Now that you’ve got that down, let’s work more with `NodeLists`.



Any time there is the potential for a method to return more than one element, such as with `getElementsByClassName()`, `getElementsByTagName()`, and `querySelectorAll()`, a NodeList will be returned, even if only one element is found that matches that query.



These NodeLists are **collections**, are numbered similar to the arrays we will explore in Unit 6.

Once we get our collection, we can select a single node using array syntax (a set of square brackets).






For example, we saw that `document.getElementsByTagName('li')` returned seven list items. The NodeList would look like this:



<table style="width:100%">

<tbody>

<tr>

<th>Index</th>

<th>Element</th>

</tr>

<tr>

<td>0</td>

<td><li>Monday</li></td>

</tr>

<tr>

<td>1</td>

<td><li class="special">Tuesday</li></td>

</tr>

<tr>

<td>2</td>

<td><li class="special">Wednesday</li></td>

</tr>

<tr>

<td>3</td>

<td><li>Thursday</li></td>

</tr>

<tr>

<td>4</td>

<td><li>Friday</li></td>

</tr>

<tr>

<td>5</td>

<td><li>Saturday</li></td>

</tr>

<tr>

<td>6</td>

<td><li>Sunday</li></td>

</tr>

</tbody>

</table>



Note how each node has an associated index associated. These indexes are _zero-based_ – meaning the first node has an index of 0, the second node has an index of 1, etc.



To locate the fourth item in our NodeList, `<li>Thursday</li>`, we could use the following syntax:

`document.getElementsByTagName('li')[3]


Directly after the `getElementsByTagName('li')` we have the index number of the item we want to locate within square brackets, `[3]`, this would locate the item at index 3, the fourth item in the list. These indexes are just like the indexes we used when we learned about arrays.



We can also use a loop to iterate through each element in the NodeList and change each item.



Let’s look at an example:

    var listItems = document.getElementsByTagName('li');

    for (var i = 0; i < listItems.length; i++) {
      listItems[i].className = 'day';
    }

This would loop through the NodeList and change the class name for each item to 'day.'






Once we've selected an individual element, we can then either make a change to this element or select another element based on its relationship to the first one.

You'll often hear this referred to as **traversing the DOM**.



![](http://circuits-assets.generalassemb.ly/prod/asset/5046/Slide-48-Codeblock.svg)





In an HTML document, elements can be nested inside of other elements.

![](http://circuits-assets.generalassemb.ly/prod/asset/5047/Slide-49-Codeblock-Annotated.svg





In programming, relationships between the document and elements are often described in the same terms one would use to describe a family tree.

![](http://circuits-assets.generalassemb.ly/prod/asset/5048/Slide-50-Codeblock-Parent-Children.svg


JavaScript has methods we can use to find an element based on an initial selection criteria. For example:

`parentNode()`

This method will locate the parent of an initial selection.

`document.getElementsByTagName('li')[0].parentNode()`

This will return the parent of the first `<li>` element, which, in this case, is the `<ul>` element, as it wraps all the `<li>` elements.



Some other methods we can use include:

*   `previousSibling()` – Will find the previous sibling of a selected element.
*   `nextSibling()` – Will find the next sibling of a selected element.
*   `firstChild()` – Will find the first child of a selected element.
*   `lastChild()` – Will find the last child of a selected element.



Let’s practice:



    Colors

    Red
    Blue
    Yellow

Traverse the DOM to make the following selections:

*   Select the parent node of the first li element:

        document.getElementsByTagName('li')[0].parentNode()

*   Select the lastChild of the ul:

        document.getElementsByTagName('ul')[0].lastChild()

<div class="repl-console" data-lang="javascript">`document.body.innerHTML = '

# Colors

*   Red
*   Blue
*   Yellow

';



![](http://circuits-assets.generalassemb.ly/prod/asset/4611/Slide-54-2-Steps.svg


Now that we've done all that hard work finding elements, we can actually do something with them!



Let’s start by manipulating the DOM.



We'll be using this HTML page as a reference in the following examples:

    <!DOCTYPE html>
    <html>
    <head>
    <meta charset="utf-8">
    <title>To Do List</title>
    <link rel="stylesheet" href="style.css">
    </head>
    <body>
    <h1>Things To Do</h1>
    <ul>
    <li>Email Mom</li>
    <li>Take out the trash</li>
    <li id="important">Return library books</li>
    </ul>
    </body>
    </html>



It will look like this when it is first loaded into the browser:

![](http://circuits-assets.generalassemb.ly/prod/asset/5088/Slide-73-Call-Mom.svg


So how do you access and update content? There are lots of different properties and methods that allow us to read and update the contents of a DOM node.

Let's take a quick look at a couple of these methods.



Let’s start with `innerHTML`.

We can use the `innerHTML` property to get and set content for an element.



For example, if we want to change the HTML content for the first `<li>`, we could execute the following:

    document.getElementsByTagName('li')[0].innerHTML = 'Email Mom.';



`innerHTML` would find the first `<li>` and change the HTML content to "Email **<a href="mom@gmail.com">**Mom**</a>**."

![](http://circuits-assets.generalassemb.ly/prod/asset/4613/Slide-59-Things-To-Do.svg


If we simply want to retrieve the HTML content to use later on, we can grab it and save it in a variable, like so:

    var firstListItem = document.getElementsByTagName('li')[0].innerHTML;



Now, let’s turn our attention to the concept of `textContent`.



This property allows us to get and set the text content for an element. For example:

    document.getElementById('important').textContent = 'Done!'

This code would change the text content of the `<li>`, which has the ID `important` to 'Done!'.



So how do innerHTML and textContent differ? When we are setting content with textContent any HTML will be displayed as text:

    document.querySelector('p').textContent = "Visit my Site";

Result:

![](http://circuits-assets.generalassemb.ly/prod/asset/5149/textContent.png)



In contrast, when setting content with the innerHTML method, any HTML tags will be inserted into the page as actual HTML content, not just text:

    document.querySelector('p').innerHTML = "Visit my Site";

Result:

![](http://circuits-assets.generalassemb.ly/prod/asset/5150/innerHTML.png)



Everything making sense so far?

Let’s try a brief exercise to test your knowledge.



    Colors

    Red
    Blue
    Yellow

How would we use the `innerHTML` method to do the following:

*   Change the text of the first list item to "Red baby!"?: 

        document.getElementsByTagName('li')[0].innerHTML = 'Red baby!';

*   Change the text of the last list item to "Mellow yellow!"?: 

        document.getElementsByTagName('li')[2].innerHTML = 'Mellow Yellow!';

<div class="repl-console" data-lang="javascript">`document.body.innerHTML = '

# Colors

*   Red
*   Blue
*   Yellow

';


    Colors

    Red
    Blue
    Yellow

How would we use the `textContent` method to do the following:

*   Change the text of the second list item to "Royal Blue"?: 

        document.getElementsByTagName('li')[1].textContent = 'Royal Blue';

*   Change the text of the last list item to "School Bus Yellow"?: 

        document.getElementsByTagName('li')[2].textContent = 'School Bus Yellow';

<div class="repl-console" data-lang="javascript">`document.body.innerHTML = '

# Colors

*   Red
*   Blue
*   Yellow

';


How did you do?

If you struggled anywhere, take note of how you got stuck, so we can help you moving forward. For now, let’s keep going.



To add new elements to the page, we'll need to use a three step process:

1.  We will use the `createElement()` method to create a new element, which can then be added to the page. When this node is created, it will be _empty_. This element will be stored in a variable.
2.  Next we will add content to the element using the `innerHTML` or `textContent` properties.
3.  Now that our element has been created, we can add it as a child of an element using the `appendChild()` method. This will add an element as the last child of the parent element.



To add a fourth item to our list we can execute the following code:

    // First up, let's create a new list
    // item and store it in a variable.
    var newListItem = document.createElement('li');

    // Alright, now let's update the
    //text content of that list item.
    newListItem.textContent = 'Feed the cat';

    // And finally, let's add that list
    //item as a child of the ul.
    document.getElementsByTagName('ul')[0].appendChild(newListItem);

![](http://circuits-assets.generalassemb.ly/prod/asset/4614/Slide-69.png


It’s time for you to give it a try.



    Colors

    Red
    Blue
    Yellow

How can you use the `createElement` and `appendChild` methods to create a fourth list item that says "Orange" and add it to the end of the list?




<div class="repl-console" data-lang="javascript">`document.body.innerHTML = '

# Colors

*   Red
*   Blue
*   Yellow

';

1.  First, let's create a new list item and store it in a variable:

        var newListItem = document.createElement('li');

2.  Alright, now let's update the text content of that list item:

    newListItem.textContent = 'Orange';

4.  Finally, let's add that list item as a child of the ul.

    document.getElementsByTagName('ul')[0].appendChild(newListItem);

6.  Nice job, let's look at the contents of the ul:

    document.getElementsByTagName('ul')[0]



Let’s talk some more about getting and setting attributes.

We can change the value of a class attribute for an element using the `className` property. This will apply the styles in our CSS associated with that particular class.



For example, maybe we want to highlight an important task on our list. We can add a class and styles in our CSS like so:

    .highlight {
              background-color: yellow;
          }



Then, we can use JavaScript to add this class:

    document.getElementById('important').className = 'highlight';



The `.highlight` class will then be added to the element with the id `important` and the background-color associated with this class will be applied:

![](http://circuits-assets.generalassemb.ly/prod/asset/4615/Slide-73-Things-To-Do.svg


Let’s try a quick exercise.



    Colors

        Red
        Blue
        Yellow

How would we use the `className` method to:

Add the class _fun_ to the third list item?

Answer:

    document.getElementsByTagName('li')[2].className = 'fun';



    Colors

    Red
    Blue
    Yellow

How would we use the `className` method to:

Add the class _important_ to the first list item?

Answer:

    document.getElementsByTagName('li')[0].className = 'important';



Here's one more method for altering attributes.



We can set and remove attributes from elements using the setAttribute() and removeAttribute()methods.

For example, if we want to update the href attribute on an anchor, we could do the following:

    document.getElementsByTagName('a')[0].setAttribute('href', 'http://newurl.com');

Here 'href' is the name of the attribute we want to change, and 'http://newurl.com' is the new value for that attribute — a url.



Or, if we wanted to remove the id from an element, we could execute the update like so:

    document.getElementsByTagName('a')[0].removeAttribute('id');



Let’s try these methods out (we promise, this is the last test in this lesson).



    Colors

    Red
    Blue
    Yellow

How would we use the `removeAttribute` and `setAttribute` methods to:

Remove the yellow id from the third list item?

Answer:

    document.getElementsByTagName('li')[2].removeAttribute('id');

<div class="repl-console" data-lang="javascript">`document.body.innerHTML = '

# Colors

*   Red
*   Blue
*   Yellow

';


Add a src attribute pointing to the source images/cat.jpg to the first image on a webpage?

Answer:

    document.getElementsByTagName('img')[0].setAttribute('src', 'images/cat.jpg');

<div class="repl-console" data-lang="javascript">`document.body.innerHTML = '';


In this lesson, we learned some basic methods that will add interactivity to our sites. And, just wait — the real fun hasn’t even begun.



In order to create interactive and responsive sites, we'll often want to update the DOM based on our user's actions.

For example, when a user clicks on our site’s menu icon, a sidebar menu should slide out from the side of the page. Or, if a user types an incorrect format into a form field, that field should become outlined in red.

These actions are called **events**.






Take a look at this GIF.

Here, we can see a cursor scroll over to the hamburger menu on the top left, where a sidebar menu appears



![](http://circuits-assets.generalassemb.ly/prod/asset/4723/click_1.gif)



JavaScript is different than most other programming languages because it is designed specifically to work in the event-driven environment of a browser window.



JS is not just executed line by line and then forgotten. When a browser loads HTML and CSS, it then uses its interpreter to run your JavaScript.

Once your JS has fully loaded, it lives in the background of your browser window, waiting and listening for any event triggers you’ve programmed.



As its name implies, in event-driven programming, the flow of a program is driven by events.



This means:

*   The program continually "waits" or listens for events to occur.

*   There are many kinds of events, such as clicking, tabbing into a form field, pressing a computer key down or letting a computer key up, scrolling, resizing the browser window, etc. We'll take a look at some of these events later in this lesson.

*   The event acts as a “trigger,” which calls, or runs, a function.



Event loops are an important part of event-driven programming.



The browser is continually checking to see if an event has occurred. When it does happen, the event loop uses a trigger function to identify which code to run.

So, if someone clicks on a menu option, what should the program do?



It should run an event handler.

These are pieces of code that will run once an event occurs. If someone clicks on a button or menu option, the event handler kicks in.

![](http://circuits-assets.generalassemb.ly/prod/asset/4616/Slide-8-Event-Loop.svg


There are many benefits of working within an event-driven system.

For one, when you’re programming around events, coding becomes somewhat intuitive (i.e., you wait for user take an action, and then you **respond** to that action).



Let’s look at another example in the GIF below.

Here we are **waiting for the user to scroll**. When the user does scroll, we run a function that changes the background color of the navigation bar (nav) and fixes its position so that it "sticks" to the top of the screen.

![](http://circuits-assets.generalassemb.ly/prod/asset/4656/Slide-10.gif


So, how do we set up, or write, event handlers?

We mentioned previously that we can set up **event handlers** in our scripts that will listen, or wait, for an event to occur and then trigger a function.



The syntax for setting up an event handler looks like this:

![](http://circuits-assets.generalassemb.ly/prod/asset/5363/Slide-12-Element.svg)

`element` - refers to the DOM node with which we want to tie the event. For example, if we want to trigger an event when the user clicks on a button, the element would be that button element.



The syntax for setting up an event handler looks like this:

![](http://circuits-assets.generalassemb.ly/prod/asset/4618/Slide-13-Dot.svg)

`.` - ties the method on the right hand side (addEventListener) with the element on the left hand side.



The syntax for setting up an event handler looks like this:

![](http://circuits-assets.generalassemb.ly/prod/asset/4619/Slide-14-addEventListener.svg)

`addEventListener()` - is the method we will use to tie an event listener to an element.



The syntax for setting up an event handler looks like this:

![](http://circuits-assets.generalassemb.ly/prod/asset/5138/Slide-15-nameOfEvent.svg)

`'nameOfEvent'` - is of the event for which we want to listen. For example, maybe we want to wait until the user triggers a 'click' event.



The syntax for setting up an event handler looks like this:

![](http://circuits-assets.generalassemb.ly/prod/asset/5139/Slide-16-functionToRun.svg)

`'functionToRun'` - is the name of the function we want to run when the event occurs. When we pass a function as an argument to another function, like we are here, this is what is referred to as a **callback function**.



_Note that there are no parentheses after the function name._
( `functionToRun` not `functionToRun()` )



Let's take a look at an example of an event handler:

    // Let's set up a function that will be triggered when the event occurs.
    var alertUser = function () {
      alert('Button has been clicked!');
    }

    // Next let's find the element we want to tie
    //the event to and save it to a variable.
    var button = document.querySelector('button');

    // Finally let's set up an event handler.
    // When the user clicks on the button,
    // the alertUser function will run.
    button.addEventListener('click', alertUser);



There are many events that can trigger a function. Here are a few:

![](http://circuits-assets.generalassemb.ly/prod/asset/4622/Slide-18-Chart.svg)

'focus' - When the user clicks or tabs into a form field and it receives focus 'blur' - When the user clicks or hits tab away from a form field and it loses focus



To start, we'll look at another example of an event handler.

Say we've created a simple form that allows users to subscribe to our email newsletter.

When the user tabs or clicks away from the email input field, we want to make sure the user has entered a value in the field.

Move on to the next slide to take a look at the code for our email newsletter.





Here, we have a simple HTML snippet of an email form.



![](http://circuits-assets.generalassemb.ly/prod/asset/4623/Slide-20-HTML.svg)





The form contains an input field where the user can enter an email address, a button for submitting the form, and a paragraph with the id _message_ that currently does not have any text inside of it.



![](http://circuits-assets.generalassemb.ly/prod/asset/4623/Slide-20-HTML.svg)





Our stylesheet (on the right side of the image) is also very basic.

All we have is a class _error_, which will give a solid red border to any elements that have the _error_ class.

![](http://circuits-assets.generalassemb.ly/prod/asset/4624/Slide-21-CSS.svg


Take a look at the code for our email newsletter:

![](http://circuits-assets.generalassemb.ly/prod/asset/4625/Slide-22-JS.svg


On the right, we've added our JS using event handlers.

![](http://circuits-assets.generalassemb.ly/prod/asset/4625/Slide-22-JS.svg


Let's take a look at what the page looks like when the user hits tab or clicks away from the email field without entering any information.






The email input now has the _error_ class, giving the input field a red border.

We've also added a message in the paragraph with the id _message_ alerting the user they need to enter an email address.

![](http://circuits-assets.generalassemb.ly/prod/asset/4626/Slide-24-Email-Form.svg


It’s time to test yourself.






      Red
      Blue
      Yellow



    function turnRed () {
      document.querySelector('body').style.backgroundColor = "red";
    }
    function turnBlue () {
      document.querySelector('body').style.backgroundColor = "blue";
    }
    function turnYellow () {
      document.querySelector('body').style.backgroundColor = "yellow";
    }


How would we add event handlers to:

Run the turnRed function when the #red element is clicked?

Answer:

    document.querySelector('#red').addEventListener('click', turnRed);






      Red
      Blue
      Yellow



    function turnRed () {
      document.querySelector('body').style.backgroundColor = "red";
    }
    function turnBlue () {
      document.querySelector('body').style.backgroundColor = "blue";
    }
    function turnYellow () {
      document.querySelector('body').style.backgroundColor = "yellow";
    }


How would we add event handlers to:

Run the turnBlue function when the #blue element is clicked?

Answer:

    document.querySelector('#blue').addEventListener('click', turnBlue);






      Red
      Blue
      Yellow



    function turnRed () {
      document.querySelector('body').style.backgroundColor = "red";
    }
    function turnBlue () {
      document.querySelector('body').style.backgroundColor = "blue";
    }
    function turnYellow () {
      document.querySelector('body').style.backgroundColor = "yellow";
    }


How would we add event handlers to:

Run the turnYellow function when the #yellow element is clicked?

Answer:

    document.querySelector('#yellow').addEventListener('click', turnYellow);



In this lesson, we learned how we can react to our users' actions when they visit our site.

We saw how we can harness JavaScript's event handling to wait until the user takes an action — like clicking on a button or scrolling down the page — and then run a block of code, or a function, when this event occurs.



In the next lesson, we'll dive even deeper into handling events. This will allow us to further control the flow of events on our sites.



In the last lesson we took a look at how we can program events to occur automatically, or wait until our users do something and then run some code in response.

Now we’re going to take a closer look at events, and see how we can run multiple functions when one occurs.



Let’s start off by talking more about event handler callbacks.

As we saw in a previous unit, the keyword `this` refers to the object that "owns" the function that the executed code runs within.



It’s important to remember that when we have a method that is inside an object, `this` refers to the object that contains that method.



For example, in the function below, `this` refers to the object that contains the makeNoise method, rover.

    var rover = {
      name: 'Rover',
      species: 'dog',
      breed: 'Golden Retreiver',
      noise: 'bark',
      makeNoise: function () {
        console.log(this.noise);
      }
    }



However, when a callback function is executed within the context of an event handler, it is the element (the DOM node) that owns the context.

So in this case, `this` will refer to the element that we selected when we set up our event handler.



Let’s look at an example where we’ll change the background color of a circle from blue to red, just by clicking on it:

![](http://circuits-assets.generalassemb.ly/prod/asset/4627/Slide-7a-HTML-JS.svg


Let’s look at an example where we’ll change the background color of a circle from blue to red, just by clicking on it:

![](http://circuits-assets.generalassemb.ly/prod/asset/4628/Slide-7b-HTML-JS-Annotated.svg


Here when we click on the circle and trigger the turnRed function, `this` will refer to the element with the class `circle` within the `turnRed` function.



Here’s what that looks like in action:

![](http://circuits-assets.generalassemb.ly/prod/asset/4629/Slide-8.gif


Alright, but why use the keyword `this`:

`this.style.backgroundColor = "red";`

Instead of just writing:

`document.querySelector('.circle').style.backgroundColor = "red";


Well, let's imagine that there are several circles on our page:

And we only want the `.circle` that we just clicked to have the updated red background color. That is where the `this` keyword really becomes useful.



Let’s take a look:

    //Select all elements with the class .circle on the page
      var circles = document.querySelectorAll('.circle');

    //loop through each .circle element and add an event handler.
      for (var i = 0; i < circles.length; i++) {
        circles[i].addEventListener('click', turnRed);
      }

      function turnRed () {
        this.style.backgroundColor = "red";
      }



Here we are adding an event handler to each element with the class `.circle`.

When an element with the `.circle` class gets clicked, the `turnRed` function will be called; within that `turnRed` function, `this` will only refer to the `.circle` that triggered the `turnRed` function and not to any of the other circles.

So now only the background color of the circle **we just clicked** will be changed to red.



Let's see this in action:

![](http://circuits-assets.generalassemb.ly/prod/asset/4630/Slide-11.gif)

See how we are only adding the style attribute to the circle we are currently clicking on (i.e., the one that triggered the callback function)? Pretty cool, huh?



Now it’s your turn to test yourself.



      Blue Jeans
      Denim
      Chambray
      Dark Wash
      Light Wash

How could we write code that would change the text of any list item that is clicked to "Forever!"? Start by writing code to select all list items on the page.

Click on the next slide to reveal the answer when you’re ready.



Did your code look something like this?

    var listItems = document.querySelectorAll('li');



Now loop through each list item and add a handler that runs a function called _sayForever_.

Click on the next slide to reveal the answer when you’re ready.



Here’s the answer:

    for (var i = 0; i < listItems.length; i++) {
      listItems[i].addEventListener('click', sayForever);
    }



Now you need to define a _sayForever_ function. From within the function it should change the innerHTML of the item that was just clicked to _“Forever!”_.

(Hint: make sure to use the _this_ keyword)

Click on the next slide to reveal the answer when you’re ready.



Ready? Here’s the answer:

    function sayForever () {
      this.innerHTML = "Forever!";
    }



There may be instances where we want to trigger multiple functions when an event occurs.

For example, maybe when our user clicks the "submit" button we want to run a function that will check to see if the form is valid and call another function that will display a "loading" icon.

In a case like this, we’d have multiple event handlers for one event.



To trigger multiple functions, first define the functions that you want to be called when our event occurs.

For example, on the next slide, we define two functions: showLoadingIcon() and checkEmailInput().




    function showLoadingIcon() {
      document.getElementById('loading').style.display = "block";
    }
    function checkEmailInput() {
      var emailInputField = document.querySelector('input');
        // Check to see whether the user has entered a value to the email field.
        if (emailInputField.value.length === 0) {
          // If the email field is blank, display a message to the user.
          document.getElementById('message').innerText = 'Please enter an email address.'
          // Add an error class to the input field that will give it a red border.
          emailInputField.className = 'error';
        } else {
          // Otherwise, clear out the error message.
          document.getElementById('message').innerText = '';
          // Remove the error class from the input field
          emailInputField.className = '';
        }
    }



Alternatively, you could write something like this, which should still get the point across:

    function showLoadingIcon() {
      // Code to show the loading icon
    }

    function checkEmailInput() {
      // Code that checks to see if the user entered an email address
      // And adds a red border to the input and an error message if not.
    }



We’ll then need to define a third function, which will contain the previous two functions:

    function submitForm() {
      showLoadingIcon();
      checkEmailInput();
    }



Finally, we’ll assign that third function as the event handler:

    document.getElementById('submit').addEventListener('click', submitForm);



Lets recap the steps before we move on:

1.  Start with input and button elements.

3.  Attach an event listener to the button.

5.  Invoke two functions within the event handler.

*   The first function showed the loading icon.
*   The second function validated the email address.



Now that we've gotten the hang of writing event handlers, let’s talk a bit about the event object.



When an event occurs, we might want to find out some information about it.

For example, which element did the user interact with that caused the event? What type of event was it? A click event? A mouseover?

Luckily, we can use the event object to obtain this kind of information.



So how do we gain access to the event object?

First, we will need to pass the event object as a parameter.



Take a look at this example:

![](http://circuits-assets.generalassemb.ly/prod/asset/4631/Slide-25-Code.svg


Let's break this down a bit:

![](http://circuits-assets.generalassemb.ly/prod/asset/4632/Slide-26-Annotated.svg


Now if we simply use whichever parameter name we chose (in our case “e”) from within the function, we have access to the event object.

Take a look at what the event object looks when you log it to the console, and notice all of the properties we have available to us as part of the event object:

![](http://circuits-assets.generalassemb.ly/prod/asset/4633/Slide-27-Codeblock.svg


We'll take a look at a few of these properties in the following slides, but for now just note how much information about the event the event object holds.



We can use dot notation to access those properties, just like we did in Unit 4:

    document.querySelector('a').addEventListener('click', turnBlue);

      function turnBlue (e) {
        // To access a property of the event object, we can use dot notation:
          var target = e.target;

          // Log the target to the console
          console.log(target);

          document.querySelector('body').style.backgroundColor = "blue";
    }



Here we are accessing the target of the event by using dot notation `e.target`. We are then logging the target to the console.



Let's take a look at what we see in the console:

<a href="#">Turn Blue</a>

Aha! That's the target of the event, or the element we clicked on that caused the event to fire.



Or maybe we want to find out what type of event it was. We can find that out by using the type property. Here we are accessing the type of event using `e.type`. Take a look:

    document.querySelector('a').addEventListener('click', turnBlue);

    function turnBlue (e) {
      // To access a property of the event object, we can use dot notation:
      var typeOfEvent = e.type;

      // Log the type to the console
      console.log(typeOfEvent);

      document.querySelector('body').style.backgroundColor = "blue";
    }



And here's what we see in the console: `click`



Now let’s discuss another important use of the event object—**Prevent Default**.

As you may be able to tell from its name, prevent default allows us to prevent the default behavior of an event.

Some events, like clicking on a link or submitting a form, are meant to take a user to another page.





Like in the example to the right — when an anchor is clicked, the default action will take the user to another page.

If no URL is specified, the page will simply load at the top.



![](http://circuits-assets.generalassemb.ly/prod/asset/4635/Slide-34.gif)





But maybe when a user clicks on a link or submits a form, we don't want to take them to another page.

We want to make some text appear instead.



![](http://circuits-assets.generalassemb.ly/prod/asset/4635/Slide-34.gif)



To do that, we could type:

    // Here we are adding a click event to the first anchor on the page.
      // When the anchor is clicked, we will run the addMessage function.

      document.querySelector('a').addEventListener('click', addMessage);

      function addMessage () {
        // When the addMessage function runs, we will display a message   for the user.
        document.querySelector('.message').innerHTML = 'A message for the user!';
    }





Our message is added at the bottom like we had intended, but we don't want the page to jump to the top!

![](http://circuits-assets.generalassemb.ly/prod/asset/4635/Slide-34.gif


We want to override the default functionality of a link, and have a message appear instead of taking the user to another page.

But as you saw in the GIF, when the user clicks on an anchor that doesn’t have a specified URL, the page jumps up to the top.



To prevent this default behavior, we can use the `preventDefault()` method:

    document.querySelector('a').addEventListener('click', addMessage);

    function addMessage (e) {
    // Now we are preventing the default behavior, using the event object and the .preventDefault() method.
      e.preventDefault();
      document.querySelector('.message').style.display = 'block';
    }


Here again, we’re passing the event object as a parameter to our callback function.



Notice how within the function, we called the preventDefault method on the event object using dot notation:

`e.preventDefault();




Let's take a look at the result:

![](http://circuits-assets.generalassemb.ly/prod/asset/4636/Slide-37.gif


You'll often use this method when you have anchors or submit buttons on a page that you want to provide with some JavaScript functionality, instead of having them take you to another page.



Now that we have a good feel for what the event object is, let's go ahead and look at a concept that is central to event handling in JavaScript: event flow.



We've seen in the past that HTML elements can be nested inside other HTML elements. When we say "nested", we mean that one element can wrap another element.

Take a look at a quick refresher:

    Popular memes for 2016

      Hotline Bling
      Katy Perry's Left Shark
      Lil Mama Crying
      Pizza Rat
      What's Good?



Here we have a `ul` that is wrapping five `li`. Each `li`, in turn, is wrapping an anchor.

In other words, we could say that each `a` is nested inside of an `li`, and each `li` is nested inside the `ul`.

    Popular memes for 2016

      Hotline Bling
      Katy Perry's Left Shark
      Lil Mama Crying
      Pizza Rat
      What's Good?



When we hover over an anchor and click on it, JS can trigger any events that are tied to the anchor, as well as any events that are tied to any elements the `a` is nested within (i.e., the `li` it sits within, the `ul` it is also nested within).

If we zoom out a bit and remember the DOM tree, we will remember that our `ul` is nested inside the `body`, which is nested inside the `html`, which is nested inside the document object.



Events that are bound to any of these elements will trigger when we click on the `a`.

![](http://circuits-assets.generalassemb.ly/prod/asset/5152/Screen_Shot_2016-08-08_at_10.02.00_AM.png


The order in which these events fire is called **event flow**.

**Event bubbling** is when the event starts at the most specific element node and then flows outwards towards the least specific node.






![](http://circuits-assets.generalassemb.ly/prod/asset/4637/Slide-42-Event-Bubbling.svg)



Here the event will start at the `a`, the most specific node, and then work its way outward, triggering any events that might be tied to the `li`, then the `ul`, then the `body`, then finally, the `document` (in this case, the HTML doc).



Why does this matter?

Understanding event flow comes into play when the code has event handlers that are tied to the element that triggers the event and any of its ancestors or descendants.






Take a look at our example from before. We've gone ahead and tied an event handler to the `a`, `li`, `ul`, `body` and `document` elements that appends a paragraph element to the body that states "[element name] has been clicked"

![](http://circuits-assets.generalassemb.ly/prod/asset/4638/Slide-45.gif


Notice in the previous slide the order in which those messages are appended to the body: "Anchor has been clicked" is appended first, and "Document has been clicked" is appended last, since the events are flowing outwards from the most specific element.



The key concept here is that events are triggered not only for the element that we tie the event handler to, but also for any elements that element is nested inside of.

The flow in which these events happens is from the most specific element to the least specific element (outwards in the diagram).



Now let’s talk about `stopPropagation()`.

There may be instances where we don't want an event to bubble up to its ancestors.

If we want to stop this behavior, we can use the event object's `stopPropagation()` method to prevent this bubbling.



Let’s take a look:

    function addAnchorMessage (e) {
      e.stopPropagation();
      document.querySelector('body').appendChild = 'Anchor has been clicked';



Here again we pass in the event object as a parameter, “e”.

We then access the `stopPropagation()` method using dot notation. This prevents the event from bubbling up to any ancestors.






Now when we click on an anchor, we don't see messages being appended for each ancestor element since those events are no longer being triggered:

![](http://circuits-assets.generalassemb.ly/prod/asset/4639/Slide-50.gif


This is just one more helpful use of the event object!



Now you understand a bit more about event flow and how multiple event handlers may be triggered on any ancestor elements.

We took a look at how the flow of events happens—from the most specific, or target, element outwards to the least specific ancestor element.



Having a grasp on this flow will be immensely helpful in the future when you’re working on complex interactions and trying to understand the order in which events will happen.



We’ve covered quite a bit in this lesson.

We took a look at how we can trigger multiple functions on one event by calling each function from within a callback function.

We also saw how we can use the keyword this to access the individual element that caused an event to fire.



We learned that we can gain access to the event object by passing it in as a parameter to a callback function. This gives us access to the properties and methods tied to the event object from within that callback function.

And finally, we saw how events flow from the most specific element to the least specific element.



Up until this point we've been writing things out in "plain vanilla" JavaScript.

In the next lesson we'll take a look at how we can harness the power of jQuery to write JavaScript that will work in different browsers, in a much friendlier syntax.



Take a peek and get excited to meet your new best friend, jQuery:

![](http://circuits-assets.generalassemb.ly/prod/asset/4640/Slide-54-JS-jQ.svg
